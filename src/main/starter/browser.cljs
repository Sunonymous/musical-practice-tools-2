(ns starter.browser
  (:require
   ;; Require various functions and macros from kushi.core
   [kushi.core :refer (sx cssfn inject-stylesheet add-font-face add-system-font-stack defkeyframes cssfn)]
   [kushi.gui :refer (gui)]
   [kushi.theme :as theme]
   ;; IMPORTANT - If you are using defclasses to share styles, it is good practice to defined them all
   ;;   in a dedicated namespace. To ensure all of these defclasses will be available globally,
   ;;   you must require them (as we are doing here) in the ns that corresponds to your main module.
   ;;   This require must come before the requires of any other namespaces which contain ui code that
   ;;   uses one of your defclasses. As you can see in the example below, our shared-styles ns is
   ;;   required BEFORE the starter.badges ns, which contains a component that uses a shared class.
   [starter.shared-styles]
   [starter.badges :as badges]
   [par.core :refer-macros [!? ?]]
   ;; This example uses reagent
   [reagent.dom :as rdom]))

;; Injecting Stylesheets
;; ---------------------------------------------------------------------------------------------

;; Optional.
;; Using kushi.core/inject-stylesheet to load a google font.
;; The additional "preconnect" hints will improve Google Fonts performance.
(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.gstatic.com"
                    :cross-origin "anonymous"})

(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.googleapis.com"})

(inject-stylesheet {:rel "stylesheet"
                    :href "https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap"})


;; Optional.
;; Using kushi.core/inject-stylesheet to inject a static css file.
;; This stylesheet might be a css reset file, or a third-party style library.
;; This is more of an edge case, as you would typically just do this with a <link> in your index.html.
;; However, if your project uses a clj file to generate the contents of your index's <head> at build time,
;;   it may be handy to use this during development to inject new stylesheets without restarting your build.
(inject-stylesheet {:rel "stylesheet"
                    :href "css/my-global-styles.css"})



;; Adding font resources
;; ---------------------------------------------------------------------------------------------

;; Optional.
;; Using kushi.core/add-font-face macro to load a local font.
;; This will add an @font-face block to the css code/file generated by kushi.
;; The location of the font file must be a path, relative the location of the generated css file.
;; You could also use a remote url to load a hosted font file.
(add-font-face {:font-family "FiraCodeRegular"
                :font-weight "400"
                :font-style "normal"
                :src ["url(../fonts/FiraCode-Regular.woff)"]})


;; Optional.
;; Using kushi.core/add-system-font-stack macro to add a system font stack.
;; The example below would write a total of 4 `@font-face` rules to your
;; kushi css file (`normal` and `italic` for both `300`("light") & `700`("bold")).
(add-system-font-stack 300 700)



;; Defining animation keyframes
;; ---------------------------------------------------------------------------------------------

;; Using kushi.core/defkeyframes macro to define keyframes.
;; Note this example uses kushi.core/cssfn: (cssfn :rotateX :0deg). You could also just type "rotateX(0deg)".
(defkeyframes y-axis-spinner
  [:0% {:transform (cssfn :rotateY :0deg)}]
  [:100% {:transform (cssfn :rotateY :360deg)}])

(defkeyframes x-axis-spinner
  [:0% {:transform (cssfn :rotateX :0deg)}]
  [:100% {:transform (cssfn :rotateX :360deg)}])



;; Styling component elements with sx
;; ---------------------------------------------------------------------------------------------

;; You can use kushi.core/sx to co-locate all your styles within your components.
;; Media queries, pseudo-classes, pseudo-elements, combo-selectors, and dynamic runtime values are all supported.
;; You can also incorporate your own defclasses, as well as the useful defclasses that ship with kushi.

;; kushi.core/sx is a macro that returns an attribute map.
;; This map contains:
;;   - a class property containing the correct auto-generated, prefixed classnames.
;;   - If necessary, a style property containing the correct auto-generated css variable names.
;;   - All the other attributes you specify in your attributes map (supplied as an optional last arg to sx).
;;   - An optional data-ns attribute to help with browser-based debugging (see docs: "Using metadata").
;; Using a build hook for the :compile-finish stage (or similar), your css is written to a static file.


;; SOME NOTES ON SYNTAX:

;; A keyword starting with a "." represents a defined defclass that will get attached to the element.
;; Kushi ships with a small handful of very useful pre-defined defclasses.


;; A keyword containing "--" represents a css prop and value pair (split on the "--").


;; Kushi shorthand notation is optionally available for the most commonly used css-props:
;;
;;     :c--red   => :color--#191970
;;     :ai--c    => :align-items--center
;;     :ai--e    => :align-items--end
;;     :ta--r    => :text-align--right
;;     :fs--18px => :font-size--18px
;;     :d--b     => :display--block
;;     :d--f     => :display--flex
;;     :bgs--50% => :background-size--50%
;;
;; A full list of these is available here:
;; https://github.com/paintparty/kushi/blob/main/README.md


;; Standard CSS shorthand-values are written like this:
;;
;;     :b--1px:solid:#efefef
;;
;; The above is equivalent to `border: 1px solid #efefef`


;; CSS list-like values are written like this:
;;
;;     :ff--FiraCodeRegular|monospace|sans-serif
;;
;; The above is equivalent to `font-family: FiraCodeRegular, monospace, sans-serif`


;; Media queries, pseudo-classes, pseudo-elements, and combo selectors can be used like this:
;;
;;     sm:c--red
;;     sm:hover:c--blue
;;     :>a:hover:c--gold
;;     :_a:hover:c--gold
;;
;;     The below edge case requires the tuple syntax with prop being expressed as a string:
;;     ["nth:child(2):c" :red]


;; Kushi's tokenized keyword syntax does not try to support variables,
;; strings or values constructed with helper fns such as cssfn.
;; However, these can easily be expressed in the attributes style map:
;;
;;     When using a variable value (most common use case):
;;     {:style {:color my-color}}
;;
;;     When using kushi.core/cssfn to construct a value:
;;     {:style {:transform (cssfn :translateY :-100px)}}
;;
;;     When a string is desired, or necessary:
;;     {:style {:before:content "\"*\""}}




;; Now, some working code...

;; Let's define a subcomponent for the headline "layers"
;; This example component demonstrates the following:
;; 1) Using shared styles, the :headline and :twirl classes, which are defined in browser.shared-styles.
;; 2) Using dynamic values for color and animation duration.

(defn headline-layer [color duration]
  [:div
   (sx
    {:class [:headline :twirl]
     :style {:color              color
             :width              :100%
             :lh                 :38.4vw
             :animation-duration duration}})
   "Kushi"])

;; Now let's define a subcomponent for the sub-header
;; This example component demonstrates the following:

;; 1) Using kushi's shorthand syntax via tokenized keywords.
;;    These can be used for both classnames and styles.
;;    Classnames written as tokenized keywords must begin with `:.`, e.g. `:.twirl`.
;;    These tokenized keywords can be used in conjuction with kushi styles and classes specified in
;;    the attributes map (optional last argument to `sx`), in the `:style` and `:class` entries.

;; 2) Using the kushi-specific :prefix and :ident entry in the attributes map in order
;;    to create your own selector name (instead of default auto-generated selector).
;;    Note: you would typically just set the :prefix value globally in your kushi.edn.

(defn twirling-subheader [s]
  [:div
   (sx
    :.twirl
    :.relative
    :ta--center
    :ff--FiraCodeRegular|monospace|sans-serif
    :fs--16px
    :c--midnightblue
    {:prefix :kqs-
     :ident :twirling-subheader-wrapper
     :on-click #(prn "clicked!")})
s])

;; Main component. Note that 2 out of 3 divs in this component just use
;; tokenized keywords and don't need to supply the optional attributes map to sx.

(defn main-view []
  [:<>
   [:div
      (sx :.flex-col-c
          :h--100%
          :ai--c)

      ;; In this div we are using both tokenized keywords and a :style map.
      [:div
       (sx :.flex-col-sb
           :ai--c
           :w--100%
           {:style {:transform (cssfn :translateY "calc(-100vh / 8)")}})

       [:div
        (sx :.relative
            {:class [:relative]
             :style {:w :100vw
                     :h :38.5vw}})
        [headline-layer :#00adef :12s]
        [headline-layer :#fef200 :3s]
        [headline-layer :#ec018b :6s]]
       [twirling-subheader "kushi + shadow-cljs quickstart template"]]]
   [badges/links]])

;; Below is boilerplate code from https://github.com/shadow-cljs/quickstart-browser

;; start is called by init and after code reloading finishes
(defn ^:dev/after-load start []
  (rdom/render [main-view] (.getElementById js/document "app")))

(defn init []
  ;; init is called ONCE when the page loads
  ;; this is called in the index.html and must be exported
  ;; so it is available even in :advanced release builds
  (start))

;; this is called before any code is reloaded
(defn ^:dev/before-load stop [])
