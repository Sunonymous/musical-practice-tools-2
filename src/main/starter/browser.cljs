(ns starter.browser
  (:require
   ;; Require various functions and macros from kushi.core
   [kushi.core :refer (sx inject-stylesheet add-font-face add-system-font-stack defkeyframes add-google-font!)]
   [kushi.ui.snippet.core :refer [copy-to-clipboard-button]]
   ;;   IMPORTANT - If you are using defclasses(shared styles), it is good practice to defined them all
   ;;   in a dedicated namespace. To ensure all of these defclasses will be available globally,
   ;;   you must require them (as we are doing here) in the ns that corresponds to your main module.
   ;;   This require must come before the requires of any other namespaces which contain ui code that
   ;;   uses one of your defclasses. As you can see in the example below, our shared-styles ns is
   ;;   required BEFORE the starter.badges ns, which contains a component that uses a shared class.
   [starter.shared-styles]

   [starter.badges :as badges]

   ;; This example uses reagent
   [reagent.dom :as rdom]))




;; Injecting Stylesheets
;; ---------------------------------------------------------------------------------------------


;; Optional.
;; Using kushi.core/inject-stylesheet to inject a static css file.
;; This stylesheet might be a css reset file, or a third-party style library.
;; This is more of an edge case, as you would typically just do this with a <link> in your index.html.
;; However, if your project uses a clj file to generate the contents of your index's <head> at build time,
;;   it may be handy to use this during development to inject new stylesheets without restarting your build.
(inject-stylesheet {:rel "stylesheet"
                    :href "css/my-global-styles.css"})


;; Optional.
;; Using kushi.core/inject-stylesheet to load a google font.
;; The additional "preconnect" hints will improve Google Fonts performance.

(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.gstatic.com"
                    :cross-origin "anonymous"})

(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.googleapis.com"})

(inject-stylesheet {:rel "stylesheet"
                    :href "https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap"})



;; If you want to add Google Fonts, you can also just use `kushi.core/add-google-fonts!`,
;; which will abstract the above pattern (3 separate calls) into one call.

(add-google-font! {:family "Inter"
                   :styles {:normal [400 700]
                            :italic [400 700]}})


;;`kushi.core/add-google-font!` accepts any number of args, each one a single map that
;; represents a font-family and associated weights & styles. You can as many different
;; families as you want in a single go (although be mindful of performance):

(add-google-font! {:family "Playfair Display"
                   :styles {:normal [400 700]
                            :italic [400 700]}}
                  {:family "Lato"
                   :styles {:normal [100 400]}}
                  {:family "Pacifico"
                   :styles {:normal [400]}})





;; Adding webfont resources
;; ---------------------------------------------------------------------------------------------

;; Optional.
;; Using kushi.core/add-font-face macro to load a local font.
;; This will add an @font-face block to the css code/file generated by kushi.
;; The location of the font file must be a path, relative the location of the generated css file.
;; You could also use a remote url to load a hosted font file.

(add-font-face {:font-family "FiraCodeRegular"
                :font-weight "333"
                :font-style "normal"
                :src ["url(../fonts/FiraCode-Regular.woff)"]})


;; Optional.
;; Using kushi.core/add-system-font-stack macro to add a system font stack.
;; The example below would write a total of 4 `@font-face` rules to your
;; kushi css file (`normal` and `italic` for both `300`("light") & `700`("bold")).
;; This system font stack is available as `sys` e.g. :ff--sys (which in css is `font-family: sys`)

(add-system-font-stack 300 700)

;; ;; Calling `add-system-font-stack` will add a total of 8 `@font-face`
;; ;; rules (300, 400, 500, and 700 - normal and italic for each).
(add-system-font-stack)





;; Defining animation keyframes
;; ---------------------------------------------------------------------------------------------

;; Using kushi.core/defkeyframes macro to define keyframes.
(defkeyframes y-axis-spinner
  [:0% {:transform "rotateY(0deg)"}]
  [:100% {:transform "rotateY(360deg)"}])

(defkeyframes x-axis-spinner
  [:0% {:transform "rotateX(0deg)"}]
  [:100% {:transform "rotateX(360deg)"}])




;; Styling component elements with sx
;; ---------------------------------------------------------------------------------------------

;; You can use kushi.core/sx to co-locate all your styles within your components.
;; Media queries, pseudo-classes, pseudo-elements, combo-selectors, and dynamic runtime values are all supported.
;; You can also incorporate your own defclasses, as well as the useful defclasses that ship with Kushi.

;; kushi.core/sx is a macro that returns an attribute map.
;; This map contains:
;;   - a class property containing the correct auto-generated, hashed prefixed classnames.
;;   - If necessary, a style property containing the correct auto-generated css variable names.
;;   - All the other attributes you specify in your attributes map (supplied as an optional last arg to sx).
;;   - An optional data-ns attribute to help with browser-based debugging (see docs: "Using metadata").

;; Using a build hook for the :compile-finish stage (or similar), your css is written to a static file.


;; SOME NOTES ON SYNTAX:

;; A keyword starting with a "." represents a defined defclass that will get attached to the element.
;; Kushi ships with a small handful of useful pre-defined defclasses.


;; A keyword containing "--" represents a css prop and value pair (split on the "--").


;; Kushi shorthand notation is optionally available for the most commonly used css-props:
;;
;;     :c--red   => :color--red
;;     :ai--c    => :align-items--center
;;     :ai--e    => :align-items--end
;;     :ta--r    => :text-align--right
;;     :fs--18px => :font-size--18px
;;     :d--b     => :display--block
;;     :d--f     => :display--flex
;;     :bgs--50% => :background-size--50%
;;

;; A partial list of these is available here:
;; https://github.com/paintparty/kushi#styles-as-keywords


;; Standard CSS shorthand-values are written like this:
;;
;;     :b--1px:solid:#efefef
;;
;; The above is equivalent to `border: 1px solid #efefef`


;; CSS list-like values are written like this:
;;
;;     :ff--FiraCodeRegular|monospace|sans-serif
;;
;; The above is equivalent to `font-family: FiraCodeRegular, monospace, sans-serif`


;; Media queries, pseudo-classes, pseudo-elements, and combo selectors can be used like this:
;;
;;     sm:c--red
;;     sm:hover:c--blue
;;     :>a:hover:c--gold
;;     :_a:hover:c--gold
;;
;;     The below edge case (because "(" and ")" chars are not valid in keywords) requires
;;     the tuple syntax with prop being expressed as a string:
;;     ["nth:child(2):c" :red]



;; You can use runtime variable values with the tuple syntax.
;;     (sx [:c mycolor])

;;     You could also write this as:
;;     (sx {:style {:color mycolor})


;; The tuple syntax is also necessary for css functions and string values.
;;
;;     Expressing a value as a css function:
;;     (sx [:transform '(translateY :-100px)])
;;     (sx {:style {:transform '(translateY :-100px)}})
;;
;;     When a string is desired, or necessary:
;;     (sx [:before:content "\"*\""])
;;     (sx {:style {:before:content "\"*\""}})



;; Now, some working code...

;; First, we define a subcomponent for the banner headline "layers"
;; This example component demonstrates the following:
;; 1) Using shared styles, the :.headline and :.twirl classes, which are defined in browser.shared-styles.
;; 2) Using kushi's shorthand syntax via tokenized keyword :animation-name--x-axis-spinner
;; 3) Using dynamic values for color and animation duration.

(defn headline-layer
  [color duration]
  [:div
   (sx
    'headline-layer
    :.headline
    :.twirl
    :animation-name--x-axis-spinner
    [:animation-duration duration]
    [:color color])
   "Kushi"])


;; Next, we define a subcomponent for the sub-header
;; This example component demonstrates the following:

;; 1) Using a quoted symbol to create your own selector name (instead of default auto-generated selector).
;; 2) Using kushi's shorthand syntax via tokenized keywords.
;; 3) Tokenized keyword with css "list" shorthand - :ff--FiraCodeRegular|monospace|sans-serif
;; 4) Using media queries - :sm:fs--14px
;; 5) Passing and attributes map (optional last arg to sx)

(defn twirling-subheader [s]
  [:div
   (sx
      'kqs-twirling-subheader-wrapper
      :.twirl
      :.relative
      :ta--center
      :ff--FiraCodeRegular|monospace|sans-serif
      :fs--12px
      :sm:fs--14px
      :fw--800
      :c--white
      {:on-click #(prn "clicked!")})
   s])


;; Main component.
(defn main-view []
  #_[:div "hi"]
  #_[:div (sx
           'profs

         ;;  :.barz
         ;;  :--myvar--red
         ;;  (when true :.gold)

           #_22
           #_[333 :bad]

           :.wtf
           (if true :.trueclass :.falseclass)
           [:p mycolor]
           [:hover:p (if true mycolor mycolor2)]

        ;;  [:hover:>div:m :30px]
        ;;  [:md:hover:>div:m :33px]
        ;;  [:md:hover&>div:m :48px]
        ;;  [:sm:hover&>div:m :49px]
        ;;  [:lg:hover&>div:m :50px]

            ;; ["nth-child(2):m" :30px]
            ;; [:sm:p :20px]
            ;; ;; [:sm:hover:p :30px]
            ;; ;; [:sm:hover:>div:m :30px]
            ;; [:md:p :33px]
            ;; ;; [:md:hover:>div:m :50px]
            ;; [:m (when true :10px)]
            ;; {:class [:foo]
           {:on-click #(js/console.log "HI")
            :class    [:foo]
            :style    {:bgc :red
                  ;; 11   :gold
                  ;; 12   :silver
                       :m   :10px}})
     "hi"]

  #_[:div (sx :.xlarge
            ;; "1"
              :c--red
              [:p :10px]
              {:style {:bgc :aliceblue
                    ;;  11   :gold
                       :m   :10px
                    ;;  12   :silver
                       }
               })
     "Hello Hello"
     [hoho "hohos"]]
  #_[:div.wtf
     [:h1 (sx :.relative
              :ta--center
              "badstring"
              :.sans
              :p--10px
              12
              :fs--18px
              :c--#efefef)
      "hi"]]

  [:div
   (sx
    'main-app-wrapper
    :ff--sys)
   [:div
    (sx :.flex-col-c
        :.absolute-fill
        :h--100%
        :ai--c
        :bgc--black)

    ;; In this div we are using both tokenized keywords and a tuple.
    [:div
     (sx 'wtfx
         :.flex-col-sb
         :ai--c
         :w--100%
         :h--200px
         :sm:h--375px
         :md:h--500px
         [:transform "translateY(calc(-100vh / 33))"])

     [:div
      [headline-layer "var(--howlite-blue)" :12s]
      [headline-layer "var(--canary-yellow)" :3s]
      [headline-layer  "var(--deep-fuscsia)" :6s]]
     [twirling-subheader "kushi × shadow-cljs quickstart"]]]
   [badges/links]])


;; Below is boilerplate code from https://github.com/shadow-cljs/quickstart-browser

;; start is called by init and after code reloading finishes
(defn ^:dev/after-load start []
  (rdom/render [main-view] (.getElementById js/document "app")))

(defn init []
  ;; init is called ONCE when the page loads
  ;; this is called in the index.html and must be exported
  ;; so it is available even in :advanced release builds
  (start))

;; this is called before any code is reloaded
(defn ^:dev/before-load stop [])
