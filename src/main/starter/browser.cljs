(ns starter.browser
  (:require

   ;; Require various functions and macros from kushi.core
   [kushi.core :refer (sx cssfn inject-stylesheet add-font-face defkeyframes cssfn clean! )]

   ;; IMPORTANT - If you are using defclasses to share styles, it is good practice to defined them all
   ;;   in a dedicated namespace. To ensure all of these defclasses will be available globally,
   ;;   you must require them (as we are doing here) in the ns that corresponds to your main module.
   ;;   This require must come before the requires of any other namespaces which contain ui code that
   ;;   uses one of your defclasses. As you can see in the example below, our shared-styles ns is
   ;;   required BEFORE the starter.badges ns, which contains a component that uses a shared class.
   [starter.shared-styles]
   [starter.badges :as badges]

   ;; This example uses reagent
   [reagent.dom :as rdom]))


;; Development housekeeping
;; ---------------------------------------------------------------------------------------------

;; kushi.core/clean! removes all existing styles that were injected into #_kushi-dev_ style tag.
;; These styles are only injected in development builds, for instant preview of changes.
;; You only need to call this once, from your project's main/core ns.
(clean!)


;; Injecting Stylesheets
;; ---------------------------------------------------------------------------------------------

;; Using kushi.core/inject-stylesheet to load a google font.
;; The additional "preconnect" hints will improve Google Fonts performance.
(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.gstatic.com"
                    :cross-origin "anonymous"})

(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.googleapis.com"})

(inject-stylesheet {:rel "stylesheet"
                    :href "https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap"})


;; Using kushi.core/inject-stylesheet to inject a static css file.
;; This stylesheet might be a css reset file, or a third-party style library.
;; This is more of an edge case, as you would typically just do this with a <link> in your index.html.
;; However, if your project uses a clj file to generate the contents of your index's <head> at build time,
;;   it may be handy to use this during development to inject new stylesheets without restarting your build.
(inject-stylesheet {:rel "stylesheet"
                    :href "css/my-global-styles.css"})



;; Adding font resources
;; ---------------------------------------------------------------------------------------------

;; Using kushi.core/add-font-face macro to load a local font.
;; This will add an @font-face block to the css file generated by kushi.
;; The location of the font file must be a path, relative the location of the generated css file.
;; You could also use a remote url to load a hosted font file.
(add-font-face {:font-family "FiraCodeRegular"
                :font-weight "400"
                :font-style "normal"
                :src ["url(../fonts/FiraCode-Regular.woff)"]})



;; Defining animation keyframes
;; ---------------------------------------------------------------------------------------------

;; Using kushi.core/defkeyframes macro to define keyframes.
;; Note this example uses kushi.core/cssfn: (cssfn :rotateX :0deg). You could also just type "rotateX(0deg)".
(defkeyframes :y-axis-spinner
  [:0% {:transform (cssfn :rotateY :0deg)}]
  [:100% {:transform (cssfn :rotateY :360deg)}])

(defkeyframes :x-axis-spinner
  [:0% {:transform (cssfn :rotateX :0deg)}]
  [:100% {:transform (cssfn :rotateX :360deg)}])



;; Styling component elements with sx
;; ---------------------------------------------------------------------------------------------

;; You can use kushi.core/sx to co-locate all your styles within your components.
;; Media queries, pseudo-classes, pseudo-elements, combo-selectors, and dynamic runtime values are all supported.
;; You can also incorporate your own defclasses, as well as the useful defclasses that ship with kushi.

;; kushi.core/sx is a macro that returns an attribute map.
;; This map contains:
;;   - a class property containing the correct auto-generated, prefixed classnames.
;;   - If necessary, a style property containing the correct auto-generated css variable names.
;;   - All the other attributes you specify in your attributes map (supplied as an optional last arg to sx).
;;   - An optional data-ns attribute to help with browser-based debugging (see docs: "Using metadata").
;; Using a build hook for the :compile-finish stage (or similar), your css is written to a static file.


;; SOME NOTES ON SYNTAX:

;; A keyword starting with a "." represents a defined defclass that will get attached to the element.
;; Kushi ships with a small handful of very useful pre-defined defclasses.


;; A keyword containing "--" represents a css prop and value pair (split on the "--").


;; Kushi shorthand notation is optionally available for the most commonly used css-props:
;;
;;     :c--red   => :color--#191970
;;     :ai--c    => :align-items--center
;;     :ai--e    => :align-items--end
;;     :ta--r    => :text-align--right
;;     :fs--18px => :font-size--18px
;;     :d--b     => :display--block
;;     :d--f     => :display--flex
;;     :bgs--50% => :background-size--50%
;;
;; A full list of these is available in the kushi README.


;; Standard CSS shorthand-values are written like this:
;;
;;     :b--1px:solid:#efefef
;;
;; The above is equivalent to `border: 1px solid #efefef`


;; CSS list-like values are written like this:
;;
;;     :ff--FiraCodeRegular|monospace|sans-serif
;;
;; The above is equivalent to `font-family: FiraCodeRegular, monospace, sans-serif`


;; Any css prop-value declaration can also be written as tuple (2-element vector)
;; By convention, this form should only be used in the following cases:
;;
;;     When using a variable value(most common):
;;     [:color my-color]
;;
;;     When using kushi.core/cssfn to construct a value:
;;     [:transform (cssfn :translateY :-100px)]
;;
;;     When a string is desired, or necessary:
;;     [:before:content "\"*\""]


;; Media queries, pseudo-classes, pseudo-elements, and combo selectors can be used like this:
;;
;;     sm:c--red
;;     sm:hover:c--blue
;;     :>a:hover:c--gold
;;     :_a:hover:c--gold
;;
;;     The below edge case requires the tuple syntax with prop being expressed as a string:
;;     ["nth:child(2):c" :red]




;; Now, some working code...

;; First let's define some colors for examples of using variable values in our styles.
(def my-colors
  {:yellowish :#fef200
   :cyanish :#00adef
   :magentaish :#ec018b})

;; A subcomponent for the headline "layers"
;; This example component also demonstrates the following:
;; 1) Using a shared style - the :.headline class, which is defined in browser.shared-styles
;; 2) Passing optional element attributes map to kushi.core/sx
;; 3) Including the kushi-specific :f entry in the attributes map.
;;    The value of :f must be the var-quoted name of the component function.
;;    This will add a 'data-ns' attr to the resulting element, the value of which will be "starter.browser/headline-layer::headline-layer-wrapper:172". Useful for debugging.
;; 4) Using the kushi-specific :prefix and :ident entry in the attributes map, in order to create your own selector name (instead of default auto-generated selector).
;;    If you wanted to do this, you would typically just set the :prefix value once, globally, in your kushi.edn.

(defn headline-layer [color x y]
  (let [f #'headline-layer]
    [:div
     (sx
      :.headline
      [:c color]
      [:left x]
      [:top y]
      {:prefix :kqs-
       :ident :headline-layer-wrapper
       :f f
       :on-click #(prn "clicked!")})
     "Kushi"]))

;; Main component
(defn main-view []
  [:<>
   [:div
    (sx :.flex-col-c
        :h--100%
        :ai--c)
    [:div
     (sx :.flex-col-sb
         :ai--c
         :w--100%
         :h--293px
         [:transform (cssfn :translateY "calc(-100vh / 8)")])
     [:div
      (sx :.relative
          :.twirl
          :animation-name--x-axis-spinner
          :w--628px
          :h--242px)
      [headline-layer (:cyanish my-colors) :-17px :17px]
      [headline-layer (:yellowish my-colors) :20px :8px]
      [headline-layer (:magentaish my-colors) 0 0]]
     [:div
      (sx
       :.relative
       :.twirl
       :ta--center
       :ff--FiraCodeRegular|monospace|sans-serif
       :fs--16px
       :c--midnightblue)
      "kushi + shadow-cljs quickstart template"]]]
   [badges/octocat]])

;; Below is boilerplate code from https://github.com/shadow-cljs/quickstart-browser

;; start is called by init and after code reloading finishes
(defn ^:dev/after-load start []
  (rdom/render [main-view] (.getElementById js/document "app")))

(defn init []
  ;; init is called ONCE when the page loads
  ;; this is called in the index.html and must be exported
  ;; so it is available even in :advanced release builds
  (start))

;; this is called before any code is reloaded
(defn ^:dev/before-load stop [])
