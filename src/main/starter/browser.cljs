(ns ^:dev-always starter.browser
  (:require

   ;; Require various functions and macros from kushi.core
   [kushi.core :refer (sx clean! inject-stylesheet add-font-face defkeyframes cssfn)]

   ;; If you are using defclasses to share styles, it is good practice to defined them all
   ;;   in a dedicated namespace in your project and require that namespace once in your
   ;;   core/main namespace like we are doing here. All defclasses will be available globally.
   [starter.shared-styles]

   ;; This example uses reagent
   [reagent.dom :as rdom]))


;; Development housekeeping
;; ---------------------------------------------------------------------------------------------

;; kushi.core/clean! removes all existing styles that were injected into #_kushi-dev_ style tag.
;; These styles are only injected in development builds, for instant preview of changes.
;; You only need to call this once, from your project's main/core ns.
(clean!)


;; Injecting Stylesheets
;; ---------------------------------------------------------------------------------------------

;; Using kushi.core/inject-stylesheet to load a google font.
;; The additional "preconnect" hints will improve Google Fonts performance.
(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.gstatic.com"
                    :cross-origin "anonymous"})

(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.googleapis.com"})

(inject-stylesheet {:rel "stylesheet"
                    :href "https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap"})


;; Using kushi.core/inject-stylesheet to inject a static css file.
;; This stylesheet might be a css reset file, or a third-party style library.
;; This is more of an edge case, as you would typically just do this with a <link> in your index.html.
;; However, if your project uses a clj file to generate the contents of your index's <head> at build time,
;;   it may be handy to use this during development to inject new stylesheets without restarting your build.
(inject-stylesheet {:rel "stylesheet"
                    :href "css/my-global-styles.css"})



;; Adding font resources
;; ---------------------------------------------------------------------------------------------

;; Using kushi.core/add-font-face macro to load a local font.
;; This will add an @font-face block to the css file generated by kushi.
;; The location of the font file must be a path, relative the location of the generated css file.
;; You could also use a remote url to load a hosted font file.
(add-font-face {:font-family "FiraCodeRegular"
                :font-weight "400"
                :font-style "normal"
                :src ["url(../fonts/FiraCode-Regular.woff)"]})



;; Defining animation keyframes
;; ---------------------------------------------------------------------------------------------

;; Using kushi.core/defkeyframes macro to define keyframes.
;; Note this example uses kushi.core/cssfn: (cssfn :rotateX :0deg). You could also just type "rotateX(0deg)".
(defkeyframes :y-axis-spinner
  [:0% {:transform (cssfn :rotateY :0deg)}]
  [:100% {:transform (cssfn :rotateY :360deg)}])

(defkeyframes :x-axis-spinner
  [:0% {:transform (cssfn :rotateX :0deg)}]
  [:100% {:transform (cssfn :rotateX :360deg)}])



;; Styling component elements with sx
;; ---------------------------------------------------------------------------------------------

;; You can use kushi.core/sx to co-locate all your styles within your components.
;; Media queries, pseudo-classes, pseudo-elements, combo-selectors, and dynamic runtime values are all supported.
;; You can also incorporate your own defclasses, as well as the useful defclasses that ship with kushi.

;; kushi.core/sx is a macro that returns an attribute map.
;; This map contains:
;;   - a class property containing the correct auto-generated, prefixed classnames.
;;   - If necessary, a style property containing the correct auto-generated css variable names.
;;   - All the other attributes you specify in your attributes map (supplied as an optional last arg to sx).
;;   - An optional data-ns attribute to help with browser-based debugging (see docs: "Using metadata").
;; Using a build hook for the :compile-finish stage (or similar), your css is written to a static file.


;; SOME NOTES ON SYNTAX:

;; A keyword starting with a "." represents a defined defclass that will get attached to the element.
;; Kushi ships with a small handful of very useful pre-defined defclasses.


;; A keyword containing "--" represents a css prop and value pair (split on the "--").


;; Kushi shorthand notation is optionally available for the most commonly used css-props:
;;
;;     :c--red   => :color--#191970
;;     :ai--c    => :align-items--center
;;     :ai--e    => :align-items--end
;;     :ta--r    => :text-align--right
;;     :fs--18px => :font-size--18px
;;     :d--b     => :display--block
;;     :d--f     => :display--flex
;;     :bgs--50% => :background-size--50%
;;
;; A full list of these is available in the kushi README.


;; Standard CSS shorthand-values are written like this:
;;
;;     :b--1px:solid:#efefef
;;
;; The above is equivalent to `border: 1px solid #efefef`


;; CSS list-like values are written like this:
;;
;;     :ff--FiraCodeRegular|monospace|sans-serif
;;
;; The above is equivalent to `font-family: FiraCodeRegular, monospace, sans-serif`


;; Any css prop-value declaration can also be written as tuple (2-element vector)
;; By convention, this form should only be used in the following cases:
;;
;;     When using a variable value(most common):
;;     [:color my-color]
;;
;;     When using kushi.core/cssfn to construct a value:
;;     [:transform (cssfn :translateY :-100px)]
;;
;;     When a string is desired, or necessary:
;;     [:before:content "\"*\""]


;; Media queries, pseudo-classes, pseudo-elements, and combo selectors can be used like this:
;;
;;     sm:c--red
;;     sm:hover:c--blue
;;     :>a:hover:c--gold
;;     :_a:hover:c--gold
;;
;;     The below edge case requires the tuple syntax with prop being expressed as a string:
;;     ["nth:child(2):c" :red]




;; Now, some working code...

;; First let's define some colors for examples of using variable values in our styles.
(def my-colors
  {:yellowish :#fef200
   :cyanish :#00adef
   :magentaish :#ec018b})

;; A subcomponent for the headline "layers"
;; This uses the :.headline class defined in browser.shared-styles
(defn headline-layer [color x y]
  [:div
   (sx :.headline
       [:c color]
       [:left x]
       [:top y])
   "Kushi"])

;; Main component
(defn main-view []
  [:div
   (sx
    ;; :.relative
    :.flex-col-c
    :ai--c)
   [:div
    (sx :.flex-col-sb
        :ai--c
        :w--100%
        :h--283px
        [:transform (cssfn :translateY "calc(-100vh / 8)")])
    [:div
     (sx :.relative
         :w--628px
         :h--242px
         :animation--x-axis-spinner:12s:linear:infinite)
     [headline-layer (:cyanish my-colors) :-17px :17px]
     [headline-layer (:yellowish my-colors) :20px :8px]
     [headline-layer (:magentaish my-colors) 0 0]]
    [:div
     (sx
      :.relative
      :ta--center
      :ff--FiraCodeRegular|monospace|sans-serif
      :animation--y-axis-spinner:12s:linear:infinite
      :fs--18px
      :c--midnightblue)
     "Style Made Easy"]]])

;; Below is boilerplate code from https://github.com/shadow-cljs/quickstart-browser

;; start is called by init and after code reloading finishes
(defn ^:dev/after-load start []
  (rdom/render [main-view] (.getElementById js/document "app")))

(defn init []
  ;; init is called ONCE when the page loads
  ;; this is called in the index.html and must be exported
  ;; so it is available even in :advanced release builds
  (start))

;; this is called before any code is reloaded
(defn ^:dev/before-load stop [])
